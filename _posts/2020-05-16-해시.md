---
layout: post
title:  "해시"
date:   2020-05-16 07:47:23 +0900
categories: [algorithm]
---

## Hash

해시는 key-value 쌍으로 이루어 데이터를 저장하는 자료구조이다. 해시는 key-value 쌍으로 주어져 있고 배열의 인덱스를 key 값으로 사용할 수 있으므로 `검색 및 저장`이 빠르다. 더 나아가 해시함수(해시 알고리즘)을 이용하면 key-value의 1대1 대응을 특정 값으로 바꿀 수 있으므로 `암호화`에 사용된다. 해쉬 함수에 input(key)값을 넣으면 value 값이 나오므로 저장 단계의 시간복잡도는 O(1)이다. 하지만 **value가 겹치는 경우가 발생하면 1대1 대응을 위반하므로 복잡도가 높아질 수 있다.** 



## 문제

### 완주하지 못한 선수

https://programmers.co.kr/learn/courses/30/lessons/42576

#### 문제

```text
수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.

마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.
```

#### 제한사항

````
1. 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.
2. completion의 길이는 participant의 길이보다 1 작습니다.
3. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.
4. 참가자 중에는 동명이인이 있을 수 있습니다.
````

#### 예시

````
## participant, completion, return
[leo, kiki, eden]	[eden, kiki]	leo
````

#### 풀이

단순히 participant 배열의 모든 원소를 completion 원소와 비교해가면서 완주 여부를 파악하면 n*(n-1)의 복잡도가 걸리므로 복잡도가 높아진다. (participant와 completion 명단이 1명빼고 모두 같다는 점을 이용하여 알파벳 순 정렬 후 for문을 n번만 돌리면 완주하지 못한 선수를 찾을 수 있지만 이번에 해시를 이용해보도록 하자)

c++ std에는 hash_map이 들어있지 않다. 그리고 c++11 부터 해시 테이블이 추가되었는데 기존에 있던 hash_map과의 충돌 때문에 `unordered_map`으로 사용할 수 있다. (그냥 `map`은 tree로 구현하기 때문에 완전히 다른방식이다.)



unordered_map으로 만들고 효율적인 검색을 위해 `key를 이름`으로 둔다. hash map 안에서 이름을 검색하며 value를 완주여부로 이용하면 된다.

```c++
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

string solution(vector<string> participant, vector<string> completion) {
    string answer = "";    
    
    unordered_map <string, int> list_complt;

    for(int i=0; i<participant.size(); i++){
        list_complt[participant[i]]++;
    }
    for(int i=0; i<completion.size(); i++){
        list_complt[completion[i]]--;
    }
    
    for(auto pair: list_complt){
        if(pair.second > 0){
            answer = pair.first;
        }
    }
    
    return answer;
}
```

한명(key) 당 value가 1씩 더해서 들어간다. 동명이인으로 두명이 있을 때는 `list_complt` 에 2로 들어간다. 참가자를 먼저 hash에 넣고 완주자의 이름을 key값으로 검색하면서 1씩 빼줬을 때, 완주자 명단에 없는 사람은 1이상의 value값을 가지고 있을 것이다.



> hash는 1대1 대응이기 때문에 중복된 key-value가 들어갈 수 없다. 문제에서 동명이인이 있을 수 있다고 했다. 예를들어 "js"가 두명이 있을 때, hash에는 ["js": 1, "js": 1] 과 같이 들어가지 않고 ["js": 1] 로 한번만 들어가게 된다. 



### 전화번호 목록

https://programmers.co.kr/learn/courses/30/lessons/42577

#### 문제

```
전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.
전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.

구조대 : 119
박준영 : 97 674 223
지영석 : 11 9552 4421
전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.
```

#### 제한사항

```
1. phone_book의 길이는 1 이상 1,000,000 이하입니다.
2. 각 전화번호의 길이는 1 이상 20 이하입니다.
```

#### 예시

````
## phone_book, return
[119, 97674223, 1195524421]	false
````

#### 풀이

복잡도를 줄이기 위해서 한쪽 방향으로만 검색을 진행하자. string의 정렬을 이용하면 앞뒤의 관계만 검사하면 된다. `sort`는 접두사가 겹치는 순서로 정렬하므로 복잡하게 생각하지 않아도 된다. 예를들어 `["12", "5632", "56", "1268", "12891"]` 을 오름차순으로 정리하면, `["12", "1268", "12891", "56", "5632"]` 이므로 바로 뒤에 있는 문자열과 비교만 하면 된다. 비교할 때는 앞에 있는 문자열의 길이만큼 뒤에 있는 문자열을 자른 뒤에 같은지 확인하자. (`substr` 이용)

```c++
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

bool solution(vector<string> phone_book) {
    bool answer = true;
    
    sort(phone_book.begin(), phone_book.end());
    
    for(int i=0; i<phone_book.size()-1; i++){
        if(phone_book[i] == phone_book[i+1].substr(0, phone_book[i].size())){
            answer = false;
        };
    }
    return answer;
}
```





