---
layout: post
title:  "해시"
date:   2020-05-16 07:47:23 +0900
categories: [algorithm]
---

## Hash

해시는 key-value 쌍으로 이루어 데이터를 저장하는 자료구조이다. 해시는 key-value 쌍으로 주어져 있고 배열의 인덱스를 key 값으로 사용할 수 있으므로 `검색 및 저장`이 빠르다. 더 나아가 해시함수(해시 알고리즘)을 이용하면 key-value의 1대1 대응을 특정 값으로 바꿀 수 있으므로 `암호화`에 사용된다. 해쉬 함수에 input(key)값을 넣으면 value 값이 나오므로 저장 단계의 시간복잡도는 O(1)이다. 하지만 **value가 겹치는 경우가 발생하면 1대1 대응을 위반하므로 복잡도가 높아질 수 있다.** 



## 문제

### 완주하지 못한 선수

https://programmers.co.kr/learn/courses/30/lessons/42576

#### 문제

```text
수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.

마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.
```

#### 제한사항

````
1. 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.
2. completion의 길이는 participant의 길이보다 1 작습니다.
3. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.
4. 참가자 중에는 동명이인이 있을 수 있습니다.
````

#### 예시

````
## participant, completion, return
[leo, kiki, eden]	[eden, kiki]	leo
````

#### 풀이

단순히 participant 배열의 모든 원소를 completion 원소와 비교해가면서 완주 여부를 파악하면 n*(n-1)의 복잡도가 걸리므로 복잡도가 높아진다. (participant와 completion 명단이 1명빼고 모두 같다는 점을 이용하여 알파벳 순 정렬 후 for문을 n번만 돌리면 완주하지 못한 선수를 찾을 수 있지만 이번에 해시를 이용해보도록 하자)

c++ std에는 hash_map이 들어있지 않다. 그리고 c++11 부터 해시 테이블이 추가되었는데 기존에 있던 hash_map과의 충돌 때문에 `unordered_map`으로 사용할 수 있다. (그냥 `map`은 tree로 구현하기 때문에 완전히 다른방식이다.)



완주명단을 unordered_map으로 만들고 `key를 이름`으로 두고 `value를 완주여부`로 둔다.

```c++
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

string solution(vector<string> participant, vector<string> completion) {
    string answer = "";
    
    // 완주자 명단
    unordered_map <string, int> list_complt;
    
    for(int i=0; i<completion.size(); i++){
        list_complt.insert(make_pair(completion[i], 1));
    }
    
    // 참가자 중 list_complt에 없는 사람 찾기 (0인 사람)
    for(int i=0; i<participant.size(); i++){
        if(list_complt[participant[i]] == 0){
            answer = participant[i];
            return answer;
        }else{
            // 중복된 이름이 있을 수 있으므로 이미 체크된 한 사람은 표시해둬야한다
            list_complt[participant[i]] = 0;    
        }
        ;
    }
    return answer;
}
```

완주자 hash_map은 `list_complt["eden"] = 1` 과 같이 저장된다. eden을 앞에와 같이 조회하면 1을 내뱉는다. 이미 확인을 한 참가자는 0으로 바꿔줘야 동일인물 중 한명이 완주자가 아닐 때 완주자가 아닌 사람으로 판단할 수 있다.







