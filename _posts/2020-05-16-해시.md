---
layout: post
title:  "해시"
date:   2020-05-16 07:47:23 +0900
categories: [algorithm]
---

## Hash

해시는 key-value 쌍으로 이루어 데이터를 저장하는 자료구조이다. 해시는 key-value 쌍으로 주어져 있고 배열의 인덱스를 key 값으로 사용할 수 있으므로 `검색 및 저장`이 빠르다. 더 나아가 해시함수(해시 알고리즘)을 이용하면 key-value의 1대1 대응을 특정 값으로 바꿀 수 있으므로 `암호화`에 사용된다. 해쉬 함수에 input(key)값을 넣으면 value 값이 나오므로 저장 단계의 시간복잡도는 O(1)이다. 하지만 **value가 겹치는 경우가 발생하면 1대1 대응을 위반하므로 복잡도가 높아질 수 있다.** 



## 문제

### 완주하지 못한 선수

https://programmers.co.kr/learn/courses/30/lessons/42576

#### 문제

```text
수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.

마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.
```

#### 제한사항

````
1. 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.
2. completion의 길이는 participant의 길이보다 1 작습니다.
3. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.
4. 참가자 중에는 동명이인이 있을 수 있습니다.
````

#### 예시

````
## participant, completion, return
[leo, kiki, eden]	[eden, kiki]	leo
````

#### 풀이

단순히 participant 배열의 모든 원소를 completion 원소와 비교해가면서 완주 여부를 파악하면 n*(n-1)의 복잡도가 걸리므로 복잡도가 높아진다. (participant와 completion 명단이 1명빼고 모두 같다는 점을 이용하여 알파벳 순 정렬 후 for문을 n번만 돌리면 완주하지 못한 선수를 찾을 수 있지만 이번에 해시를 이용해보도록 하자)

c++ std에는 hash_map이 들어있지 않다. 그리고 c++11 부터 해시 테이블이 추가되었는데 기존에 있던 hash_map과의 충돌 때문에 `unordered_map`으로 사용할 수 있다. (그냥 `map`은 tree로 구현하기 때문에 완전히 다른방식이다.)



unordered_map으로 만들고 효율적인 검색을 위해 `key를 이름`으로 둔다. hash map 안에서 이름을 검색하며 value를 완주여부로 이용하면 된다.

```c++
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

string solution(vector<string> participant, vector<string> completion) {
    string answer = "";    
    
    unordered_map <string, int> list_complt;

    for(int i=0; i<participant.size(); i++){
        list_complt[participant[i]]++;
    }
    for(int i=0; i<completion.size(); i++){
        list_complt[completion[i]]--;
    }
    
    for(auto pair: list_complt){
        if(pair.second > 0){
            answer = pair.first;
        }
    }
    
    return answer;
}
```

한명(key) 당 value가 1씩 더해서 들어간다. 동명이인으로 두명이 있을 때는 `list_complt` 에 2로 들어간다. 참가자를 먼저 hash에 넣고 완주자의 이름을 key값으로 검색하면서 1씩 빼줬을 때, 완주자 명단에 없는 사람은 1이상의 value값을 가지고 있을 것이다.



> hash는 1대1 대응이기 때문에 중복된 key-value가 들어갈 수 없다. 문제에서 동명이인이 있을 수 있다고 했다. 예를들어 "js"가 두명이 있을 때, hash에는 ["js": 1, "js": 1] 과 같이 들어가지 않고 ["js": 1] 로 한번만 들어가게 된다. 







